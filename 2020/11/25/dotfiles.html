<h1 id="automating-provisioning-arch-continued---dotfiles">Automating provisioning Arch continued - dotfiles</h1>

<ol id="markdown-toc">
  <li><a href="#automating-provisioning-arch-continued---dotfiles" id="markdown-toc-automating-provisioning-arch-continued---dotfiles">Automating provisioning Arch continued - dotfiles</a>    <ol>
      <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li>
      <li><a href="#repository-setup" id="markdown-toc-repository-setup">Repository setup</a></li>
      <li><a href="#repository-root-files" id="markdown-toc-repository-root-files">Repository root files</a>        <ol>
          <li><a href="#setupsh" id="markdown-toc-setupsh">setup.sh</a></li>
          <li><a href="#base-rcrc" id="markdown-toc-base-rcrc">base-rcrc</a></li>
          <li><a href="#other-root-files" id="markdown-toc-other-root-files">other root files</a></li>
        </ol>
      </li>
      <li><a href="#bash" id="markdown-toc-bash">bash</a>        <ol>
          <li><a href="#completions" id="markdown-toc-completions">completions</a></li>
          <li><a href="#distrosmanjaroaliases" id="markdown-toc-distrosmanjaroaliases">distros/manjaro/aliases</a></li>
          <li><a href="#linux" id="markdown-toc-linux">linux</a></li>
          <li><a href="#macos" id="markdown-toc-macos">macos</a></li>
          <li><a href="#windows-wsl" id="markdown-toc-windows-wsl">windows-wsl</a></li>
          <li><a href="#nerdfonts" id="markdown-toc-nerdfonts">nerdfonts</a></li>
          <li><a href="#shared" id="markdown-toc-shared">shared</a>            <ol>
              <li><a href="#aliases" id="markdown-toc-aliases">aliases</a></li>
              <li><a href="#exports" id="markdown-toc-exports">exports</a></li>
              <li><a href="#functions" id="markdown-toc-functions">functions</a></li>
              <li><a href="#options" id="markdown-toc-options">options</a></li>
              <li><a href="#other" id="markdown-toc-other">other</a></li>
              <li><a href="#third-party" id="markdown-toc-third-party">third party</a></li>
            </ol>
          </li>
        </ol>
      </li>
      <li><a href="#bin" id="markdown-toc-bin">bin</a></li>
      <li><a href="#filesmac-and-iterm2" id="markdown-toc-filesmac-and-iterm2">files/mac and iterm2</a></li>
      <li><a href="#rcs" id="markdown-toc-rcs">rcs</a>        <ol>
          <li><a href="#bash_logout" id="markdown-toc-bash_logout">bash_logout</a></li>
          <li><a href="#bash_profile" id="markdown-toc-bash_profile">bash_profile</a></li>
          <li><a href="#bashrc" id="markdown-toc-bashrc">bashrc</a></li>
          <li><a href="#other-files" id="markdown-toc-other-files">other files</a></li>
          <li><a href="#config-folder" id="markdown-toc-config-folder">config folder</a></li>
          <li><a href="#host--folders" id="markdown-toc-host--folders">host-* folders</a></li>
          <li><a href="#tag--folders" id="markdown-toc-tag--folders">tag-* folders</a></li>
          <li><a href="#vifm-and-vim" id="markdown-toc-vifm-and-vim">vifm and vim</a></li>
        </ol>
      </li>
      <li><a href="#hooks" id="markdown-toc-hooks">hooks</a></li>
      <li><a href="#conclusion" id="markdown-toc-conclusion">conclusion</a></li>
    </ol>
  </li>
</ol>

<h2 id="introduction">Introduction</h2>

<p>In what is hopefully the last in this series on configuring my computer I’ll go through setting up configuration files (also called dotfiles or rcs).</p>

<p>As with the earlier posts in this series I’ll be copying liberally from <a href="https://github.com/brennanfee/dotfiles">Brennan Fee</a>. Since I’m building off his guide I will also use <a href="https://thoughtbot.github.io/rcm/rcm.7.html">RCM</a> to manage my dotfiles. At the time of this writing I don’t think I need a lot of the tag or host specific tools it offers, and I could probably stick with using my old approach of a <a href="https://www.atlassian.com/git/tutorials/dotfiles">bare git repository</a> right in my home. This seems a bit cleaner though, and maybe I’ll want to extend it eventually. The idea of being able to extend things to WSL or MacOS is cool and I could see using host or tag specific features to be able to use these on work machines as well.</p>

<p>I have a hard time remembering why I structure my dotfiles the way I do, or what some features do, so hopefully by writing all this out I will make it easier to update them in the future. As a bonus maybe this will be useful to others looking to configure their own environments. I’m not going to dissect the files in this document, it’s too easy to let things get out of sync between this guide and my actual dotfiles. Instead this will focus on explaining the directory structure and what files do what, since that’s not easily captured by comments. I’ll try to heavily comment the actual files in the repository. That will have a slightly better chance of staying relevant.</p>

<h2 id="repository-setup">Repository setup</h2>

<p>Following Brennan’s example, I have two repositories to contain my configs. The first is for configuration I don’t mind sharing and it’s available <a href="https://github.com/ianepreston/dots">here</a>. In addition to that I have a second private repository for configurations that contain personal information, which I will not be sharing a link to for obvious reasons.</p>

<p>Just for reference in this guide the public dotfiles repository is cloned to <code class="language-plaintext highlighter-rouge">~/.dotfiles</code>, which is the default location for RCM. The private ones are cloned to <code class="language-plaintext highlighter-rouge">~/.private_dotfiles</code>. That one I’ll have to manually specify, and if I want to add a file to it I’ll have to move it over manually.</p>

<h2 id="repository-root-files">Repository root files</h2>

<h3 id="setupsh">setup.sh</h3>

<p>This file either links in or generates the config file for RCM (rcrc). This is the file that identifies which tags are applicable for the machine so it has to be configured properly before the rest of the dotfiles can be brought up. The base implementation checks what Operating System you’re running and adds tags for that. At work I have it generate additional tags for which user is running it so I can create user specific tagged files (for things like email addresses).</p>

<p>After running this script, if we didn’t link in an already existing <code class="language-plaintext highlighter-rouge">.rcrc</code> file then you’ll have a host specific one generated, but it won’t be saved in the repository, it will just be a reglar file. If as prompted you run <code class="language-plaintext highlighter-rouge">mkrc -o ~/.rcrc</code> it will add a host specific rcrc file to the repository.</p>

<h3 id="base-rcrc">base-rcrc</h3>

<p>This file is used by <code class="language-plaintext highlighter-rouge">setup.sh</code> to generate the host specific <code class="language-plaintext highlighter-rouge">~/.rcrc</code>. The script adds tags to this file based on the operating system you’re running. You can add additional tags if you’d like.</p>

<h3 id="other-root-files">other root files</h3>

<p>The other files in the root of the repository are generic repository management files. README.md will show on the base of the page on GitHub and should point back to this blog post for more details. I picked GPL V3 for the license somewhat arbitrarily. I think I used the GitHub license picker helper for it. <code class="language-plaintext highlighter-rouge">.gitignore</code> and <code class="language-plaintext highlighter-rouge">.gitattributes</code> handle files for git to ignore and enforce consistent line break characters. <code class="language-plaintext highlighter-rouge">.editorconfig</code> tells a variety of text editors things like whether to use tabs or spaces for indentation.</p>

<h2 id="bash">bash</h2>

<p>This folder contains all the stuff that gets loaded into my profile at login. It’s where things like custom functions and the layout of my command prompt are defined.</p>

<h3 id="completions">completions</h3>

<p>These scripts let you tab complete commands for certain applications. At the time of this writing I have completions for git, pipx and poetry installed.</p>

<h3 id="distrosmanjaroaliases">distros/manjaro/aliases</h3>

<p>I don’t actually use manjaro, but I wanted to keep this in as an example for myself of how to set distribution specific functionality.</p>

<h3 id="linux">linux</h3>

<p>This has a few commands to set <code class="language-plaintext highlighter-rouge">start</code> or <code class="language-plaintext highlighter-rouge">open</code> to run <code class="language-plaintext highlighter-rouge">xdg-open</code> in linux. Makes the syntax compatible against platforms. That would be for opening a file in a gui rather than with a command line app.</p>

<h3 id="macos">macos</h3>

<p>I don’t have any mac machines to test this stuff out on right now. It’s got a few files that presumably help make behaviour consistent on macs.</p>

<h3 id="windows-wsl">windows-wsl</h3>

<p>Similar to the mac and linux entries above. Lets you use the same commands regardless of your specific platform.</p>

<h3 id="nerdfonts">nerdfonts</h3>

<p>This maps a bunch of <a href="https://www.nerdfonts.com/">nerd fonts</a> to environment variables so they can be included in shell scripts. It lets you do things like put a check mark in your command prompt. Very important stuff.</p>

<h3 id="shared">shared</h3>

<p>This is where the bulk of the content is in the bash directory. All of these files are cross platform and should work the same on linux, mac or WSL.</p>

<h4 id="aliases">aliases</h4>

<p>Basically these are all the command shortcuts. For example <code class="language-plaintext highlighter-rouge">alias grep="grep --color"</code> means you can just type <code class="language-plaintext highlighter-rouge">grep</code> but get nicely coloured results.</p>

<h4 id="exports">exports</h4>

<p>This is where environment variables are set. For example <code class="language-plaintext highlighter-rouge">EDITOR=vim</code> is set here.</p>

<h4 id="functions">functions</h4>

<p>This is where user defined functions/tools live. For example <code class="language-plaintext highlighter-rouge">extract</code> is defined here to call the appropriate underlying app to extract a file based on its extension.</p>

<h4 id="options">options</h4>

<p>Sets a bunch of shell options. Things like turning on vi mode for the command line.</p>

<h4 id="other">other</h4>

<p>A catch all. Code to set up conda, manage the file path, and actually set the appearance of my command prompt all live here.</p>

<h4 id="third-party">third party</h4>

<p>A place to dump cool code snippets you found on the internet that you want to be able to manage in your shell.</p>

<h2 id="bin">bin</h2>

<p>As opposed to the functions in the bash folder that get added to your environment, these are scripts that are supposed to be called directly, and are therefore on the path but not parsed until they’re called. At least I think that’s the distinction. I’m not super good at bash namespaces yet so this might need to be edited.</p>

<h2 id="filesmac-and-iterm2">files/mac and iterm2</h2>

<p>I don’t have a mac, not totally sure what this stuff does. But maybe some day I will! Then it’ll be super nice to have this stuff enabled… I assume.</p>

<h2 id="rcs">rcs</h2>

<p>This is where the actual config files live</p>

<h3 id="bash_logout">bash_logout</h3>

<p>Clear the screen when you log out. I’m not sure if I actually need this, doesn’t seem to hurt</p>

<h3 id="bash_profile">bash_profile</h3>

<p>I’m sure in theory there’s a difference between this file and <code class="language-plaintext highlighter-rouge">.bashrc</code> but in practice they seem to be the same. Just map this one to load <code class="language-plaintext highlighter-rouge">~/.bashrc</code> so whichever one your terminal expects you get the same result.</p>

<h3 id="bashrc">bashrc</h3>

<p><code class="language-plaintext highlighter-rouge">bashrc</code> configures your shell on login. Brennan has a nice modular design that I’m going to emulate. Basically nothing goes in bashrc itself, rather it walks through all the folders in the previously described bash folder and adds them in (at least those relevant to your Operating System). A snippet of what that looks like is below.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># We want to walk "outside" in... which is to say run all options files first, then all</span>
<span class="c"># exports, then all functions, etc.</span>
<span class="k">for </span>folder <span class="k">in</span> <span class="s2">"options"</span> <span class="s2">"exports"</span> <span class="s2">"functions"</span> <span class="s2">"third-party"</span> <span class="s2">"other"</span> <span class="s2">"aliases"</span><span class="p">;</span> <span class="k">do
  for </span>base <span class="k">in</span> <span class="s2">"shared"</span> <span class="s2">"</span><span class="nv">$OS_PRIMARY</span><span class="s2">"</span> <span class="s2">"distros/</span><span class="nv">$OS_SECONDARY</span><span class="s2">"</span><span class="p">;</span> <span class="k">do
    for </span>root <span class="k">in</span> <span class="s2">"</span><span class="nv">$DOTFILES</span><span class="s2">/bash"</span> <span class="s2">"</span><span class="nv">$DOTFILES_PRIVATE</span><span class="s2">/bash"</span><span class="p">;</span> <span class="k">do
      if</span> <span class="o">[[</span> <span class="nt">-d</span> <span class="s2">"</span><span class="nv">$root</span><span class="s2">/</span><span class="nv">$base</span><span class="s2">/</span><span class="nv">$folder</span><span class="s2">"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
        for </span>file <span class="k">in</span> <span class="nv">$root</span>/<span class="nv">$base</span>/<span class="nv">$folder</span>/<span class="k">*</span>.bash<span class="p">;</span> <span class="k">do</span>
          <span class="c"># shellcheck source=/dev/null</span>
          <span class="nb">source</span> <span class="s2">"</span><span class="nv">$file</span><span class="s2">"</span>
        <span class="k">done
      fi
    done
  done
done</span>
</code></pre></div></div>

<p>All the actual functionality lives in the <code class="language-plaintext highlighter-rouge">bash</code> folders of the dotfiles repositories and only this file itself needs to be linked in by RCM. Distribution and OS specific functionality can be managed by just placing the script in the appropriate folder. Because of the order of execution the more granular files will overwrite more general settings if there’s a conflict.</p>

<h3 id="other-files">other files</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">dircolors</code>: make <code class="language-plaintext highlighter-rouge">ls</code> show pretty colours.</li>
  <li><code class="language-plaintext highlighter-rouge">gitignore</code>: files and patterns to ignore in all git repositories</li>
  <li><code class="language-plaintext highlighter-rouge">inputrc</code>: manage basic keyboard mappings for the shell (home to go to the beginning of the line for example)</li>
  <li><code class="language-plaintext highlighter-rouge">prettierrc</code>: configurations for the code formatter prettier. Kind of like <a href="https://pypi.org/project/black/">black</a> for other languages</li>
  <li><code class="language-plaintext highlighter-rouge">tmux.conf</code>: configuration for <a href="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/">tmux</a>. I don’t use tmux enough to have strong opinions about these commands so the commenting is pretty sparse at the time of this writing</li>
</ul>

<h3 id="config-folder">config folder</h3>

<p>Polite applications store their configuration files here rather than your home directory. The <a href="https://wiki.archlinux.org/index.php/XDG_Base_Directory#User_directories">Arch Wiki</a> has a good list of polite applications and how to override some of the impolite ones. The folders all correspond to the name of the application they configure (e.g. git) so they layout is pretty self explanatory.</p>

<h3 id="host--folders">host-* folders</h3>

<p>Host specific configs. Everything within here will have the same layout as the <code class="language-plaintext highlighter-rouge">rcs</code> folder above it, but will have machine specific configs. For my setup that’s just the <code class="language-plaintext highlighter-rouge">~/.rcrc</code> file that sets the tags for everything else on the machine.</p>

<h3 id="tag--folders">tag-* folders</h3>

<p>The same idea as hosts, except each host can have multiple tags. In general this is used for OS specific configurations. At work I also add tags for each user on the system for things like configuring e-mail addresses.</p>

<h3 id="vifm-and-vim">vifm and vim</h3>

<p>These folder should really be under config. They’re just the settings for vim and vifm. Rude of them to demand their own space in <code class="language-plaintext highlighter-rouge">~</code>.</p>

<h2 id="hooks">hooks</h2>

<p>These just live in the <code class="language-plaintext highlighter-rouge">rcs</code> folder, but they’re special so I want to give them their own place. Some configurations need to have setup steps run, either before they’re installed or after. For instance, you can specify which plugins you want vim to use, but they won’t actually be installed until you run <code class="language-plaintext highlighter-rouge">vim -N -u "$HOME/.vim/vimrc.bundles" +PlugUpdate +PlugClean! +qa -</code>. You can put a script that does that in <code class="language-plaintext highlighter-rouge">hooks/post-up</code> and it will automatically run that after loading in your configuration files. I’m pushing this feature a little beyond what it’s intended to install some user level things like miniconda and pyenv. Doing that with this tool doesn’t quite fit its intended use, but it seems to work so I’ll stick with it.</p>

<h2 id="conclusion">conclusion</h2>

<p>This guide gave an overview of the structure of my dotfiles. For more details on the tool used to set them up check out <a href="https://thoughtbot.com/blog/rcm-for-rc-files-in-dotfiles-repos">RCM</a> and for the specifics of the configurations check the files themselves in <a href="https://github.com/ianepreston/dots">my repository</a>.</p>
